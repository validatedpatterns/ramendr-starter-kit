apiVersion: batch/v1
kind: CronJob
metadata:
  name: argocd-health-monitor
  namespace: open-cluster-management
  labels:
    app.kubernetes.io/name: argocd-health-monitor
    app.kubernetes.io/component: cronjob
  annotations:
    argocd.argoproj.io/compare-options: IgnoreExtraneous
    argocd.argoproj.io/sync-wave: "1"
spec:
  schedule: "*/15 * * * *"  # Run every 15 minutes
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  jobTemplate:
    spec:
      backoffLimit: 2
      template:
        spec:
          restartPolicy: OnFailure
          containers:
          - name: argocd-health-monitor
            image: registry.redhat.io/openshift4/ose-cli:latest
            command:
            - /bin/bash
            - -c
            - |
              set -euo pipefail
              
              echo "Starting ArgoCD health monitoring and remediation..."
              
              # Configuration
              MAX_ATTEMPTS=3
              SLEEP_INTERVAL=20
              ARGOCD_NAMESPACE="openshift-gitops"
              HEALTH_CHECK_TIMEOUT=30
              
              # Function to check if a cluster is wedged
              check_cluster_wedged() {
                local cluster="$1"
                local kubeconfig="$2"
                
                echo "Checking if $cluster is wedged..."
                
                # Check if we can connect to the cluster
                if ! oc --kubeconfig="$kubeconfig" get nodes --request-timeout=10s &>/dev/null; then
                  echo "‚ùå Cannot connect to $cluster - cluster appears wedged"
                  return 0
                fi
                
                # Check if ArgoCD namespace exists
                if ! oc --kubeconfig="$kubeconfig" get namespace "$ARGOCD_NAMESPACE" &>/dev/null; then
                  echo "‚ùå ArgoCD namespace $ARGOCD_NAMESPACE not found on $cluster - cluster appears wedged"
                  return 0
                fi
                
                # Check for exactly one openshift-gitops-operator
                local gitops_operator_pods=$(oc --kubeconfig="$kubeconfig" get pods -n "$ARGOCD_NAMESPACE" -l app.kubernetes.io/name=openshift-gitops-operator --field-selector=status.phase=Running --no-headers 2>/dev/null | wc -l)
                echo "Found $gitops_operator_pods openshift-gitops-operator pods on $cluster"
                
                if [[ $gitops_operator_pods -eq 0 ]]; then
                  echo "‚ùå No openshift-gitops-operator pods found on $cluster - cluster appears wedged"
                  return 0
                elif [[ $gitops_operator_pods -eq 1 ]]; then
                  echo "‚úÖ Found 1 openshift-gitops-operator pod on $cluster - operator is healthy"
                else
                  echo "‚ö†Ô∏è  Found $gitops_operator_pods openshift-gitops-operator pods on $cluster (expected 1) - cluster may be wedged"
                  return 0
                fi
                
                # Check for exactly two ArgoCD servers
                local argocd_server_pods=$(oc --kubeconfig="$kubeconfig" get pods -n "$ARGOCD_NAMESPACE" -l app.kubernetes.io/name=argocd-server --field-selector=status.phase=Running --no-headers 2>/dev/null | wc -l)
                echo "Found $argocd_server_pods ArgoCD server pods on $cluster"
                
                if [[ $argocd_server_pods -eq 0 ]]; then
                  echo "‚ùå No ArgoCD server pods found on $cluster - cluster appears wedged"
                  return 0
                elif [[ $argocd_server_pods -eq 1 ]]; then
                  echo "‚ùå Only 1 ArgoCD server pod found on $cluster (expected 2) - cluster appears wedged"
                  return 0
                elif [[ $argocd_server_pods -eq 2 ]]; then
                  echo "‚úÖ Found 2 ArgoCD server pods on $cluster - cluster appears healthy"
                  return 1
                else
                  echo "‚ö†Ô∏è  Found $argocd_server_pods ArgoCD server pods on $cluster (expected 2) - cluster may be wedged"
                  return 0
                fi
              }
              
              # Function to remediate a wedged cluster
              remediate_wedged_cluster() {
                local cluster="$1"
                local kubeconfig="$2"
                
                echo "üîß Remediating wedged cluster: $cluster"
                
                # Stop all ArgoCD instances by scaling down deployments
                echo "  Stopping all ArgoCD instances on $cluster..."
                oc --kubeconfig="$kubeconfig" scale deployment --all -n "$ARGOCD_NAMESPACE" --replicas=0 &>/dev/null || true
                oc --kubeconfig="$kubeconfig" scale statefulset --all -n "$ARGOCD_NAMESPACE" --replicas=0 &>/dev/null || true
                
                # If scaling doesn't work, try more aggressive cleanup
                echo "  Attempting aggressive cleanup for stuck deployments..."
                oc --kubeconfig="$kubeconfig" delete deployment --all -n "$ARGOCD_NAMESPACE" --grace-period=0 --force &>/dev/null || true
                oc --kubeconfig="$kubeconfig" delete statefulset --all -n "$ARGOCD_NAMESPACE" --grace-period=0 --force &>/dev/null || true
                oc --kubeconfig="$kubeconfig" delete pods --all -n "$ARGOCD_NAMESPACE" --grace-period=0 --force &>/dev/null || true
                
                # Wait for all instances to stop
                echo "  Waiting for ArgoCD instances to stop..."
                local attempt=1
                while [[ $attempt -le 30 ]]; do
                  local running_pods=$(oc --kubeconfig="$kubeconfig" get pods -n "$ARGOCD_NAMESPACE" --field-selector=status.phase=Running --no-headers 2>/dev/null | wc -l)
                  if [[ $running_pods -eq 0 ]]; then
                    echo "  ‚úÖ All ArgoCD instances stopped on $cluster"
                    break
                  fi
                  echo "  Waiting for instances to stop... (attempt $attempt/30)"
                  sleep 5
                  ((attempt++))
                done
                
                # Restart all ArgoCD instances by scaling up deployments
                echo "  Restarting all ArgoCD instances on $cluster..."
                oc --kubeconfig="$kubeconfig" scale deployment --all -n "$ARGOCD_NAMESPACE" --replicas=1 &>/dev/null || true
                oc --kubeconfig="$kubeconfig" scale statefulset --all -n "$ARGOCD_NAMESPACE" --replicas=1 &>/dev/null || true
                
                # Wait for pods to restart
                echo "  Waiting for ArgoCD pods to restart on $cluster..."
                local attempt=1
                while [[ $attempt -le 20 ]]; do
                  local running_pods=$(oc --kubeconfig="$kubeconfig" get pods -n "$ARGOCD_NAMESPACE" --field-selector=status.phase=Running --no-headers 2>/dev/null | wc -l)
                  local total_pods=$(oc --kubeconfig="$kubeconfig" get pods -n "$ARGOCD_NAMESPACE" --no-headers 2>/dev/null | wc -l)
                  
                  if [[ $running_pods -gt 0 && $running_pods -eq $total_pods ]]; then
                    echo "  ‚úÖ ArgoCD pods restarted successfully on $cluster"
                    break
                  fi
                  
                  echo "  Waiting for pods to restart... (attempt $attempt/20)"
                  sleep 10
                  ((attempt++))
                done
                
                if [[ $attempt -gt 20 ]]; then
                  echo "  ‚ö†Ô∏è  ArgoCD pods may not have fully restarted on $cluster"
                fi
                
                # Trigger ArgoCD refresh/sync
                echo "  Triggering ArgoCD refresh on $cluster..."
                local server_pod=$(oc --kubeconfig="$kubeconfig" get pods -n "$ARGOCD_NAMESPACE" -l app.kubernetes.io/name=argocd-server --field-selector=status.phase=Running -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
                if [[ -n "$server_pod" ]]; then
                  # Trigger refresh of all applications
                  oc --kubeconfig="$kubeconfig" exec -n "$ARGOCD_NAMESPACE" "$server_pod" -- argocd app list -o name | while read app; do
                    if [[ -n "$app" ]]; then
                      echo "    Refreshing $app..."
                      oc --kubeconfig="$kubeconfig" exec -n "$ARGOCD_NAMESPACE" "$server_pod" -- argocd app get "$app" --refresh &>/dev/null || true
                    fi
                  done
                  
                  # Trigger hard refresh
                  oc --kubeconfig="$kubeconfig" exec -n "$ARGOCD_NAMESPACE" "$server_pod" -- argocd app list -o name | while read app; do
                    if [[ -n "$app" ]]; then
                      echo "    Hard refreshing $app..."
                      oc --kubeconfig="$kubeconfig" exec -n "$ARGOCD_NAMESPACE" "$server_pod" -- argocd app get "$app" --hard-refresh &>/dev/null || true
                    fi
                  done
                fi
                
                echo "  ‚úÖ Remediation completed for $cluster"
              }
              
              # Function to download kubeconfig for a cluster (using same logic as download-kubeconfigs.sh)
              download_kubeconfig() {
                local cluster="$1"
                local kubeconfig_path="/tmp/${cluster}-kubeconfig.yaml"
                
                echo "Downloading kubeconfig for $cluster..."
                
                # Check if cluster is available (same as download-kubeconfigs.sh)
                local cluster_status=$(oc get managedcluster "$cluster" -o jsonpath='{.status.conditions[?(@.type=="ManagedClusterConditionAvailable")].status}' 2>/dev/null || echo "Unknown")
                if [[ "$cluster_status" != "True" ]]; then
                  echo "Cluster $cluster is not available (status: $cluster_status), skipping..."
                  return 1
                fi
                
                # Get the kubeconfig secret name (same approach as download-kubeconfigs.sh)
                local kubeconfig_secret=$(oc get secret -n "$cluster" -o name | grep -E "(admin-kubeconfig|kubeconfig)" | head -1)
                
                if [[ -z "$kubeconfig_secret" ]]; then
                  echo "No kubeconfig secret found for cluster $cluster"
                  return 1
                fi
                
                echo "Found kubeconfig secret: $kubeconfig_secret"
                
                # Try to get the kubeconfig data (same approach as download-kubeconfigs.sh)
                local kubeconfig_data=""
                
                # First try to get the 'kubeconfig' field
                kubeconfig_data=$(oc get "$kubeconfig_secret" -n "$cluster" -o jsonpath='{.data.kubeconfig}' 2>/dev/null | base64 -d 2>/dev/null || echo "")
                
                # If that fails, try the 'raw-kubeconfig' field
                if [[ -z "$kubeconfig_data" ]]; then
                  kubeconfig_data=$(oc get "$kubeconfig_secret" -n "$cluster" -o jsonpath='{.data.raw-kubeconfig}' 2>/dev/null | base64 -d 2>/dev/null || echo "")
                fi
                
                if [[ -z "$kubeconfig_data" ]]; then
                  echo "Could not extract kubeconfig data for cluster $cluster"
                  return 1
                fi
                
                # Write the kubeconfig to file
                echo "$kubeconfig_data" > "$kubeconfig_path"
                
                # Validate kubeconfig (same as download-kubeconfigs.sh)
                if oc --kubeconfig="$kubeconfig_path" get nodes &>/dev/null; then
                  echo "Kubeconfig downloaded and validated for $cluster"
                  
                  # Show cluster info (same as download-kubeconfigs.sh)
                  local server_url=$(echo "$kubeconfig_data" | grep -E "^\s*server:" | head -1 | awk '{print $2}' || echo "Unknown")
                  echo "  Server URL: $server_url"
                  
                  local node_count=$(oc --kubeconfig="$kubeconfig_path" get nodes --no-headers 2>/dev/null | wc -l || echo "0")
                  echo "  Node count: $node_count"
                  
                  return 0
                else
                  echo "Downloaded kubeconfig for $cluster but it may not be valid"
                  echo "  File saved as: $kubeconfig_path"
                  return 1
                fi
              }
              
              # Main monitoring loop
              attempt=1
              while [[ $attempt -le $MAX_ATTEMPTS ]]; do
                echo "=== ArgoCD Health Check Attempt $attempt/$MAX_ATTEMPTS ==="
                
                # Get list of managed clusters
                MANAGED_CLUSTERS=$(oc get managedclusters -o jsonpath='{.items[*].metadata.name}' 2>/dev/null || echo "")
                
                if [[ -z "$MANAGED_CLUSTERS" ]]; then
                  echo "No managed clusters found"
                  sleep $SLEEP_INTERVAL
                  ((attempt++))
                  continue
                fi
                
                echo "Found managed clusters: $MANAGED_CLUSTERS"
                
                wedged_clusters=()
                
                # Check each managed cluster
                for cluster in $MANAGED_CLUSTERS; do
                  if [[ "$cluster" == "local-cluster" ]]; then
                    continue
                  fi
                  
                  echo "Checking cluster: $cluster"
                  
                  # Download kubeconfig
                  if download_kubeconfig "$cluster"; then
                    kubeconfig_path="/tmp/${cluster}-kubeconfig.yaml"
                    
                    # Check if cluster is wedged
                    if check_cluster_wedged "$cluster" "$kubeconfig_path"; then
                      wedged_clusters+=("$cluster")
                    fi
                  else
                    echo "‚ö†Ô∏è  Cannot access $cluster - may be wedged"
                    wedged_clusters+=("$cluster")
                  fi
                done
                
                # Remediate wedged clusters
                if [[ ${#wedged_clusters[@]} -gt 0 ]]; then
                  echo "Found wedged clusters: ${wedged_clusters[*]}"
                  
                  for cluster in "${wedged_clusters[@]}"; do
                    if download_kubeconfig "$cluster"; then
                      kubeconfig_path="/tmp/${cluster}-kubeconfig.yaml"
                      remediate_wedged_cluster "$cluster" "$kubeconfig_path"
                    else
                      echo "‚ö†Ô∏è  Cannot remediate $cluster - kubeconfig is invalid"
                    fi
                  done
                  
                  echo "‚úÖ Remediation completed for wedged clusters"
                else
                  echo "‚úÖ All clusters are healthy"
                fi
                
                # Wait before next check
                if [[ $attempt -lt $MAX_ATTEMPTS ]]; then
                  echo "Waiting $SLEEP_INTERVAL seconds before next check..."
                  sleep $SLEEP_INTERVAL
                fi
                
                ((attempt++))
              done
              
              echo "üéâ ArgoCD health monitoring completed"
          serviceAccountName: argocd-health-monitor
