apiVersion: batch/v1
kind: Job
metadata:
  name: argocd-health-monitor
  namespace: open-cluster-management
  labels:
    app.kubernetes.io/name: argocd-health-monitor
    app.kubernetes.io/component: health-check
  annotations:
    argocd.argoproj.io/sync-wave: "0"
spec:
  backoffLimit: 3
  template:
    spec:
      restartPolicy: OnFailure
      containers:
      - name: argocd-health-monitor
        image: registry.redhat.io/openshift4/ose-cli:latest
        command:
        - /bin/bash
        - -c
        - |
          set -euo pipefail
          
          echo "Starting ArgoCD health monitoring and remediation..."
          
          # Configuration
          MAX_ATTEMPTS=5
          SLEEP_INTERVAL=30
          ARGOCD_NAMESPACE="openshift-gitops"
          HEALTH_CHECK_TIMEOUT=60
          
              # Function to check if a cluster is wedged
              check_cluster_wedged() {
                local cluster="$1"
                local kubeconfig="$2"
                
                echo "Checking if $cluster is wedged..."
                
                # Check if we can connect to the cluster
                if ! oc --kubeconfig="$kubeconfig" get nodes --request-timeout=10s &>/dev/null; then
                  echo "‚ùå Cannot connect to $cluster - cluster appears wedged"
                  return 0
                fi
                
                # Check if ArgoCD namespace exists
                if ! oc --kubeconfig="$kubeconfig" get namespace "$ARGOCD_NAMESPACE" &>/dev/null; then
                  echo "‚ùå ArgoCD namespace $ARGOCD_NAMESPACE not found on $cluster - cluster appears wedged"
                  return 0
                fi
                
                # Check for exactly one openshift-gitops-operator
                local gitops_operator_pods=$(oc --kubeconfig="$kubeconfig" get pods -n "$ARGOCD_NAMESPACE" -l app.kubernetes.io/name=openshift-gitops-operator --field-selector=status.phase=Running --no-headers 2>/dev/null | wc -l)
                echo "Found $gitops_operator_pods openshift-gitops-operator pods on $cluster"
                
                if [[ $gitops_operator_pods -eq 0 ]]; then
                  echo "‚ùå No openshift-gitops-operator pods found on $cluster - cluster appears wedged"
                  return 0
                elif [[ $gitops_operator_pods -eq 1 ]]; then
                  echo "‚úÖ Found 1 openshift-gitops-operator pod on $cluster - operator is healthy"
                else
                  echo "‚ö†Ô∏è  Found $gitops_operator_pods openshift-gitops-operator pods on $cluster (expected 1) - cluster may be wedged"
                  return 0
                fi
                
                # Check for exactly two ArgoCD servers
                local argocd_server_pods=$(oc --kubeconfig="$kubeconfig" get pods -n "$ARGOCD_NAMESPACE" -l app.kubernetes.io/name=argocd-server --field-selector=status.phase=Running --no-headers 2>/dev/null | wc -l)
                echo "Found $argocd_server_pods ArgoCD server pods on $cluster"
                
                if [[ $argocd_server_pods -eq 0 ]]; then
                  echo "‚ùå No ArgoCD server pods found on $cluster - cluster appears wedged"
                  return 0
                elif [[ $argocd_server_pods -eq 1 ]]; then
                  echo "‚ùå Only 1 ArgoCD server pod found on $cluster (expected 2) - cluster appears wedged"
                  return 0
                elif [[ $argocd_server_pods -eq 2 ]]; then
                  echo "‚úÖ Found 2 ArgoCD server pods on $cluster - cluster appears healthy"
                  return 1
                else
                  echo "‚ö†Ô∏è  Found $argocd_server_pods ArgoCD server pods on $cluster (expected 2) - cluster may be wedged"
                  return 0
                fi
              }
          
          # Function to remediate a wedged cluster with maximum violence
          remediate_wedged_cluster() {
            local cluster="$1"
            local kubeconfig="$2"
            
            echo "üîß Remediating wedged cluster: $cluster with MAXIMUM VIOLENCE"
            
            # MAXIMUM VIOLENCE: Delete everything in the openshift-gitops namespace
            echo "  üí• MAXIMUM VIOLENCE: Deleting ALL resources in $ARGOCD_NAMESPACE namespace..."
            
            # Delete all deployments with maximum force
            echo "  üí• Force deleting all deployments..."
            oc --kubeconfig="$kubeconfig" delete deployment --all -n "$ARGOCD_NAMESPACE" --grace-period=0 --force &>/dev/null || true
            
            # Delete all statefulsets with maximum force
            echo "  üí• Force deleting all statefulsets..."
            oc --kubeconfig="$kubeconfig" delete statefulset --all -n "$ARGOCD_NAMESPACE" --grace-period=0 --force &>/dev/null || true
            
            # Delete all daemonsets with maximum force
            echo "  üí• Force deleting all daemonsets..."
            oc --kubeconfig="$kubeconfig" delete daemonset --all -n "$ARGOCD_NAMESPACE" --grace-period=0 --force &>/dev/null || true
            
            # Delete all pods with maximum force
            echo "  üí• Force deleting all pods..."
            oc --kubeconfig="$kubeconfig" delete pods --all -n "$ARGOCD_NAMESPACE" --grace-period=0 --force &>/dev/null || true
            
            # Delete all services with maximum force
            echo "  üí• Force deleting all services..."
            oc --kubeconfig="$kubeconfig" delete service --all -n "$ARGOCD_NAMESPACE" --grace-period=0 --force &>/dev/null || true
            
            # Delete all configmaps with maximum force
            echo "  üí• Force deleting all configmaps..."
            oc --kubeconfig="$kubeconfig" delete configmap --all -n "$ARGOCD_NAMESPACE" --grace-period=0 --force &>/dev/null || true
            
            # Delete all secrets with maximum force
            echo "  üí• Force deleting all secrets..."
            oc --kubeconfig="$kubeconfig" delete secret --all -n "$ARGOCD_NAMESPACE" --grace-period=0 --force &>/dev/null || true
            
            # Delete all persistent volume claims with maximum force
            echo "  üí• Force deleting all PVCs..."
            oc --kubeconfig="$kubeconfig" delete pvc --all -n "$ARGOCD_NAMESPACE" --grace-period=0 --force &>/dev/null || true
            
            # Wait for everything to be deleted
            echo "  ‚è≥ Waiting for all resources to be deleted..."
            local attempt=1
            while [[ $attempt -le 60 ]]; do
              local remaining_resources=$(oc --kubeconfig="$kubeconfig" get all -n "$ARGOCD_NAMESPACE" --no-headers 2>/dev/null | wc -l)
              if [[ $remaining_resources -eq 0 ]]; then
                echo "  ‚úÖ All resources deleted from $ARGOCD_NAMESPACE namespace"
                break
              fi
              echo "  Waiting for resources to be deleted... (attempt $attempt/60) - $remaining_resources resources remaining"
              sleep 5
              ((attempt++))
            done
            
            # MAXIMUM VIOLENCE: Delete and recreate the namespace
            echo "  üí• MAXIMUM VIOLENCE: Deleting and recreating $ARGOCD_NAMESPACE namespace..."
            oc --kubeconfig="$kubeconfig" delete namespace "$ARGOCD_NAMESPACE" --grace-period=0 --force &>/dev/null || true
            
            # Wait for namespace to be deleted
            echo "  ‚è≥ Waiting for namespace to be deleted..."
            local attempt=1
            while [[ $attempt -le 30 ]]; do
              if ! oc --kubeconfig="$kubeconfig" get namespace "$ARGOCD_NAMESPACE" &>/dev/null; then
                echo "  ‚úÖ Namespace $ARGOCD_NAMESPACE deleted"
                break
              fi
              echo "  Waiting for namespace to be deleted... (attempt $attempt/30)"
              sleep 5
              ((attempt++))
            done
            
            # Recreate the namespace
            echo "  üîÑ Recreating $ARGOCD_NAMESPACE namespace..."
            oc --kubeconfig="$kubeconfig" create namespace "$ARGOCD_NAMESPACE" &>/dev/null || true
            
            # Wait for namespace to be ready
            echo "  ‚è≥ Waiting for namespace to be ready..."
            local attempt=1
            while [[ $attempt -le 30 ]]; do
              if oc --kubeconfig="$kubeconfig" get namespace "$ARGOCD_NAMESPACE" &>/dev/null; then
                echo "  ‚úÖ Namespace $ARGOCD_NAMESPACE recreated"
                break
              fi
              echo "  Waiting for namespace to be ready... (attempt $attempt/30)"
              sleep 5
              ((attempt++))
            done
            
            echo "  üí• MAXIMUM VIOLENCE remediation completed for $cluster"
            echo "  ‚ö†Ô∏è  Note: The openshift-gitops-operator will need to be reinstalled to restore functionality"
          }
          
              # Function to download kubeconfig for a cluster (using same logic as download-kubeconfigs.sh)
              download_kubeconfig() {
                local cluster="$1"
                local kubeconfig_path="/tmp/${cluster}-kubeconfig.yaml"
                
                echo "Downloading kubeconfig for $cluster..."
                
                # Check if cluster is available (same as download-kubeconfigs.sh)
                local cluster_status=$(oc get managedcluster "$cluster" -o jsonpath='{.status.conditions[?(@.type=="ManagedClusterConditionAvailable")].status}' 2>/dev/null || echo "Unknown")
                if [[ "$cluster_status" != "True" ]]; then
                  echo "Cluster $cluster is not available (status: $cluster_status), skipping..."
                  return 1
                fi
                
                # Get the kubeconfig secret name (same approach as download-kubeconfigs.sh)
                local kubeconfig_secret=$(oc get secret -n "$cluster" -o name | grep -E "(admin-kubeconfig|kubeconfig)" | head -1)
                
                if [[ -z "$kubeconfig_secret" ]]; then
                  echo "No kubeconfig secret found for cluster $cluster"
                  return 1
                fi
                
                echo "Found kubeconfig secret: $kubeconfig_secret"
                
                # Try to get the kubeconfig data (same approach as download-kubeconfigs.sh)
                local kubeconfig_data=""
                
                # First try to get the 'kubeconfig' field
                kubeconfig_data=$(oc get "$kubeconfig_secret" -n "$cluster" -o jsonpath='{.data.kubeconfig}' 2>/dev/null | base64 -d 2>/dev/null || echo "")
                
                # If that fails, try the 'raw-kubeconfig' field
                if [[ -z "$kubeconfig_data" ]]; then
                  kubeconfig_data=$(oc get "$kubeconfig_secret" -n "$cluster" -o jsonpath='{.data.raw-kubeconfig}' 2>/dev/null | base64 -d 2>/dev/null || echo "")
                fi
                
                if [[ -z "$kubeconfig_data" ]]; then
                  echo "Could not extract kubeconfig data for cluster $cluster"
                  return 1
                fi
                
                # Write the kubeconfig to file
                echo "$kubeconfig_data" > "$kubeconfig_path"
                
                # Validate kubeconfig (same as download-kubeconfigs.sh)
                if oc --kubeconfig="$kubeconfig_path" get nodes &>/dev/null; then
                  echo "Kubeconfig downloaded and validated for $cluster"
                  
                  # Show cluster info (same as download-kubeconfigs.sh)
                  local server_url=$(echo "$kubeconfig_data" | grep -E "^\s*server:" | head -1 | awk '{print $2}' || echo "Unknown")
                  echo "  Server URL: $server_url"
                  
                  local node_count=$(oc --kubeconfig="$kubeconfig_path" get nodes --no-headers 2>/dev/null | wc -l || echo "0")
                  echo "  Node count: $node_count"
                  
                  return 0
                else
                  echo "Downloaded kubeconfig for $cluster but it may not be valid"
                  echo "  File saved as: $kubeconfig_path"
                  return 1
                fi
              }
          
          # Main monitoring loop
          attempt=1
          while [[ $attempt -le $MAX_ATTEMPTS ]]; do
            echo "=== ArgoCD Health Check Attempt $attempt/$MAX_ATTEMPTS ==="
            
            # Get list of managed clusters
            MANAGED_CLUSTERS=$(oc get managedclusters -o jsonpath='{.items[*].metadata.name}' 2>/dev/null || echo "")
            
            if [[ -z "$MANAGED_CLUSTERS" ]]; then
              echo "No managed clusters found"
              sleep $SLEEP_INTERVAL
              ((attempt++))
              continue
            fi
            
            echo "Found managed clusters: $MANAGED_CLUSTERS"
            
            wedged_clusters=()
            
            # Check each managed cluster
            for cluster in $MANAGED_CLUSTERS; do
              if [[ "$cluster" == "local-cluster" ]]; then
                continue
              fi
              
              echo "Checking cluster: $cluster"
              
              # Download kubeconfig
              if download_kubeconfig "$cluster"; then
                kubeconfig_path="/tmp/${cluster}-kubeconfig.yaml"
                
                # Check if cluster is wedged
                if check_cluster_wedged "$cluster" "$kubeconfig_path"; then
                  wedged_clusters+=("$cluster")
                fi
              else
                echo "‚ö†Ô∏è  Cannot access $cluster - may be wedged"
                wedged_clusters+=("$cluster")
              fi
            done
            
            # Remediate wedged clusters
            if [[ ${#wedged_clusters[@]} -gt 0 ]]; then
              echo "Found wedged clusters: ${wedged_clusters[*]}"
              
              for cluster in "${wedged_clusters[@]}"; do
                if download_kubeconfig "$cluster"; then
                  kubeconfig_path="/tmp/${cluster}-kubeconfig.yaml"
                  remediate_wedged_cluster "$cluster" "$kubeconfig_path"
                else
                  echo "‚ö†Ô∏è  Cannot remediate $cluster - kubeconfig is invalid"
                fi
              done
              
              echo "‚úÖ Remediation completed for wedged clusters"
            else
              echo "‚úÖ All clusters are healthy"
            fi
            
            # Wait before next check
            if [[ $attempt -lt $MAX_ATTEMPTS ]]; then
              echo "Waiting $SLEEP_INTERVAL seconds before next check..."
              sleep $SLEEP_INTERVAL
            fi
            
            ((attempt++))
          done
          
          echo "üéâ ArgoCD health monitoring completed"
      serviceAccountName: argocd-health-monitor
